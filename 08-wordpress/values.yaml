## Bitnami WordPress image version
##
image:
  registry: docker.io
  repository: bitnami/wordpress
  tag: 5.1.0
  pullPolicy: IfNotPresent

## User of the application
wordpressUsername: workshop

## Application password
wordpressPassword: aWqlYYJxz9xcaZC3xggl8622q 


## Admin email
wordpressEmail: workshop@metakube.de

## First name
wordpressFirstName: workshop

## Last name
wordpressLastName: workshop

## Blog name
wordpressBlogName: Acme Blog!

## Table prefix
wordpressTablePrefix: wp_

allowEmptyPassword: true

## SMTP mail delivery configuration
##
# smtpHost:
# smtpPort:
# smtpUser:
# smtpPassword:
# smtpUsername:
# smtpProtocol:

replicaCount: 1

##
## MariaDB chart configuration
##
mariadb:
  ## Whether to deploy a mariadb server to satisfy the applications database requirements. To use an external database set this to false and configure the externalDatabase parameters
  enabled: true
  ## Disable MariaDB replication
  replication:
    enabled: false

  ## Create a database and a database user
  ##
  db:
    name: wordpress
    user: wordpress
    ## If the password is not specified, mariadb will generates a random password
    ##
    password: oXzgohE8ImumV4Q1OHHua4knP 

  ## MariaDB admin password
  ## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#setting-the-root-password-on-first-run
  ##
  rootUser:
    password: lGHDTeQdX6uAcPNrkf0vNxldI

  ## Enable persistence using Persistent Volume Claims
  ##
  master:
    persistence:
      enabled: true
      storageClass: "standard"
      accessMode: ReadWriteOnce
      size: 8Gi

## Kubernetes configuration
##
service:
  type: ClusterIP 
  # HTTP Port
  port: 80
  # HTTPS Port
  httpsPort: 443
  ##
  externalTrafficPolicy: Cluster

## Allow health checks to be pointed at the https port
healthcheckHttps: false

## Configure extra options for liveness and readiness probes
livenessProbe:
  initialDelaySeconds: 120
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1
readinessProbe:
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

## Configure the ingress resource that allows you to access the
##
ingress:
  ## Set to true to enable ingress record generation
  enabled: true

  ## Set this to true in order to add the corresponding annotations for cert-manager
  certManager: true 

  ## Ingress annotations done as key:value pairs
  ## If certManager is set to true, annotation kubernetes.io/tls-acme: "true" will automatically be set
  annotations:
    kubernetes.io/ingress.class: nginx

  ## The list of hostnames to be covered with this ingress record.
  ## Most likely this will be just one host, but in the event more hosts are needed, this is an array
  hosts:
  - name: wordpress-<YOURNAME>.unipig.de 
    path: /

    # Set this to true in order to enable TLS on the ingress record
    tls: true

    ## If TLS is set to true, you must declare what secret will store the key/certificate for TLS
    tlsSecret: blog-tls-certs

## Enable persistence using Persistent Volume Claims
## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  enabled: true
  storageClass: "standard"
  accessMode: ReadWriteOnce
  size: 10Gi

## Configure resource requests and limits
##
resources:
  requests:
    memory: 512Mi
    cpu: 300m
